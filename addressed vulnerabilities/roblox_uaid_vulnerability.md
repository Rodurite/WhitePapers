# Security: Multi-Instance UAID Vulnerability

## 1. Problem: Ambiguous Asset Tracking
Roblox items are commonly identified by two distinct identifiers:
1.  **Asset ID**: Identifies the *type* of item (e.g., "Dominus Empyreus").
2.  **UAID (User Asset ID)**: Identifies the specific *instance* of that item.

A user is permitted to own multiple copies (instances) of the same item (same Asset ID), each with a distinct UAID.

### 1.1 The Vulnerability
When a seller lists an item for sale, our system currently tracks a specific single UAID (the one selected or detected at listing time). However, if the seller owns multiple copies of that item, they might accidentally (or maliciously) transfer a *different* copy (different UAID) to the buyer.

*   **Tracking Failure**: Our system expects `UAID_A`, but the buyer receives `UAID_B`.
*   **False Negative**: The verification logic checks the buyer's inventory for `UAID_A`. It does not find it. It concludes the trade failed.
*   **Exploitable State**: The buyer could accept the trade (receiving `UAID_B`) while the system reports a failure. This could lead to the buyer receiving an automatic refund while keeping the item, causing a loss for the seller or the platform.

## 2. Proposed Solution: Composite UAID Tracking

We must shift from tracking a "Single Expected UAID" to tracking a "Set of Acceptable UAIDs".

### 2.1 Backend Storage Update
The database schema for an `Order` or `Escrow` should be updated to store a list of UAIDs instead of a single value, or a secondary lookup table should be used.
*   **Current**: `target_uaid: String`
*   **New**: `valid_seller_uaids: String[]` (Array of Strings)

### 2.2 Pre-Trade Snapshot logic
When a smart contract is initialized (or an order is "Armed"), the backend must:
1.  Identify the **Asset ID** of the item being sold.
2.  Scan the Seller's inventory for *all* instances of that Asset ID.
3.  Store this **array of all possible UAIDs** associated with that seller for that specific contract.

### 2.3 Verification Logic Update
When verifying the transfer in the `check_status` loop:
1.  Fetch the Buyer's inventory.
2.  Iterate through the **Stored Array** (`valid_seller_uaids`).
3.  Check if *any* of these UAIDs have newly appeared in the Buyer's inventory.

**Pseudocode:**
```python
# Vulnerable
def verify_trade(target_uaid, buyer_inventory):
    return target_uaid in buyer_inventory

# Secure
def verify_trade(possible_uaids, buyer_inventory):
    for uaid in possible_uaids:
        if uaid in buyer_inventory:
            return True, uaid # Return success and the specific UAID transferred
    return False, None
```

## 3. Conclusion
This preventative measure ensures that the specific instance transferred does not matter, as long as it is a valid copy originating from the seller. This eliminates "wrong instance" disputes and protects against accidental refund exploits.
